---
layout: post
title: "01 서론 ~ 02 시스템 구조"
categories: [network]
tags: []
description: >
---

<h2>1단원</h2>
<pre>
  <ul>
    POSIX : Portable Operating System Interface

    시스템의 관점에서 OS는 하드웨어와 가장 밀접하게 연관된 프로그래밍
    OS를 자원할당자(resource allocator), 제어프로그램(control program) &lt;- 특히 IO부분

    무어의 법칙(Moore's Laws) : 집적회로의 트랜지스터 수가 매 18개월마다 배가할 것이라고 예측

    OS의 존재이유 - 유용한 컴퓨터 시스템을 만드는 과정에서 발생하는 문제점을 해결하기 위한 적절한 방법
    -&gt; 자원을 제어하고 할당하는 공통기능을 하나의 소프트웨어로 통한것이 운영체제

    일반적인 정의로 운영체제는 컴퓨터에서 항상 수행되는 프로그램을 일반적으로 <strong>커널</strong>이라 불린다.
    (커널과 함께 다른 두 유형의 프로그램이 있다. 시스템 프로그램은 운영체제와 연관되어 있으며 커널의 일부분은 아니고,
    응용프로그램은 시스템의 운영과 관계없는 모든 프로그램을 포함한다.)

    미들웨어 - 응용 개발자에게 추가서비스를 제공하는 소프트웨어 프레임워크 집합

    <li><h4>1.2 컴퓨터 시스템의 구성</h4></li>
    컴퓨터가 구동을 시작하기 위해, 수행할 초기 프로그램 필요 = 부트스트랩 프로그램
    이것은 보통 펌웨어라고 알려져있고 ROM 이나 EEPROM에 저장됨, CPU 레지스터로부터 장치 제어기, 메모리 내용 등을 포함한 시스템의 모든 면을 초기화한다.
    또한 이것은 OS를 적재하는 방법 및 수행을 시작하는 방법을 알아야 함
    부트스트랩 프로그램은 OS의 커널을 찾아 메모리에 적재

    소프트웨어는 시스템 호출(system call)이라 불리는 특별한 연산을 실행하여 인터럽트를 발생시킬 수 있음

    <li><h4>1.3 단일 처리기 시스템</h4></li>
    다중 처리기 시스템은 단일 처리기 시스템보다 좋은 3가지 장점이 있다.
    1. 증가된 처리량 2. 규모의 경제 3. 증가된 신뢰성

    비대칭적 다중처리 - 하나의 주 처리기가 시스템을 제어한다. 이러한 기법은 주종 관계를 정의한다.
    대칭적 다중처리 - 모든 처리기가 대등. 처리기 간에는 주종 관계가 없다.(SMP)

    <h3>OS가 하는 일</h3>

    <li><h4>1.4</h4></li>
    다중 프로그래밍 : CPU가 수행할 작업을 항상 하나 가지도록 작업을 구성함으로써 CPU이용률 증가
    시분할은 다중 프로그래밍의 논리적 확장 (대화식 컴퓨터시스템을 필요로함)
    실행되고 있는 프로그램 : 프로세스

    <li><h4>1.5</h4></li>
    작업이 영원히 서로를 기다린다 : deadlock(교착 상태)
    OS 는 인터럽트 구동식(interrupt driven)
    사용자 모드와 커널 모드를 모드 비트를 통해서 구별한다
    악영향을 끼칠 수 있는 일부명령(특권명령) : 입출력제어, 타이머관리

    <li><h4>1.6 프로세스 관리</h4></li>
    <img src="../../images/OS/OS_modbit.png" alt="" width="500" height="350">
    모드 비트 : 커널모드(0) 사용자모드(1)
    모드 비트의 사용으로 OS를 위해 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있게 됨
    사용자 모드(User Mode) : 사용자를 위해 실행됨
    커널 모드(Kernel Mode) : 운영체제를 위해 실행됨

    <strong>프로세스(Process)</strong>는 실행중인 프로그램을 말하며, 하나의 작업이나 하나의 시분할 프로그램으로 생각할 수 있음

    <q cite="">Thread : 프로세스가 여러개 실행되면 발생되는 흐름</q>

    프로그램은 디스크에 저장된 파일 내용과 같이 수동적 개체(Passive Entity)
    <-----> 프로세스는 다음 수행할 명령을 지정하는 PC를 가진 능동적 개체(Active Entity)

    <li><h4>1.7 메모리 관리</h4></li>
    주기억장치 - CPU가 직접 주소를 지정할 수 있고, 직접 접근할 수 있는 유일한 대량의 메모리
    Keeping track, Deciding which process, Allocating and deallocating memory space
    <li><h4>1.8 저장장치 관리</h4></li>
    논리적 관점을 제공
    저장장치의 물리적 특성을 추상화한 논리적 저장 단위 -&gt; 파일(File)
    파일 시스템 관리
    컴퓨터의 전체 동작 속도는 디스크 서브시스템과 그것을 조작하는 알고리즘 속도에 의해서 결정될 수 있음

    캐시, 캐시 일관성 문제

    <li><h4>1.9 보호와 보안</h4></li>
    보호(Protection) : 컴퓨터 시스템이 정의안 자원에 대해 프로그램, 프로세스, 또는 사용자들의 접근을 제어하는 기법
    보안(Security) : 시스템 외부 또는 내부의 공격을 방어하는 것

    Privilege escalation : 리눅스에서 password 변경할때 setuid비트가 1이 되면서 /bin/passwd 에 euid가 root가 된다. 즉 권한 상승

    <li><h4>1.11 계산 환경(Computing Environments)</h4></li>

</ul>

<h2>2단원</h2>
<ul>
  <li><h4>2.1 운영체제 서비스</h4></li>
    <img src="../../images/OS/OS_service.png" alt="" width="700" height="420">
  <ol>
    <li>사용자 인터페이스</li>
    명령어 라인 인터페이스(command-line Interface, CLI)
    배치 인터페이스(batch Interface) : 명령어와 명령어를 제어하는 디렉티브가 파일 형태로 입력되고 그 파일이 실행됨
    그래피컬 사용자 인터페이스(graphical user Interface, GUI)
    <li>프로그램 수행</li>
    <li>입출력 연산</li>
    <li>파일 시스템 조작</li>
    <li>통신</li>
    공유 메모리를 통해서 구현 될 수도 있고, 메시지 전달 기법에 의해 구현 될 수도 있음
    <li>오류 탐지</li>
    <li>자원 할당</li>
    <li>회계</li>
    <li>보호(Protection)와 보안(Security)</li>
    보호 : 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 포함
    보안 : 각 사용자가 자원에 대한 접근을 허용 받기 위해 통상 패스워드를 사용해서 시스템에 자기 자신을 인증하는 것으로부터 시작
  </ol>
    <li><h4>2.2 사용자 운영체제 인터페이스</h4></li>
    명령해석기
    -어떤 OS는 커널에 명령어 해석기를 포함
    -다른 OS는 명령어 해석기를 작업이 시작되거나, 사용자가 처음 로그온 할 때 , 수행되는 특수한 프로그램으로 취급
      *선택할 수 있는 여러 명령어 해석기를 제공하는 유닉스 시스템에서는 이 해석기를 ‘쉘(Shell)’이라 함
    -명령어 해석기의 주요 기능 : 사용자가 지정한 명령을 가져와서 그것을 수행하는 것


    그래피컬 사용자 인터페이스

    <li><h4>2.3 시스템 호출(System Calls)</h4></li>
    <strong>시스템 호출은 OS에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.</strong>
    대부분의 사용자는 시스템 호출을 직접적으로 사용하기 보다는 응용 프로그램 인터페이스(Application Program Interface; API)를 통한 프로그램에 의해서 접근
    응용프로그래머는 실제 호출보다 API에 따라 프로그래밍하는 것을 선호하는 이유 : 프로그램의 호환성을 높일 수 있음, 작업하기가 더 쉬움
    <img src="../../images/OS/OS_systemcall.png" alt="" width="600" height="500">

    OS에 매개변수를 전달하기 위한 3가지 방법
    1. 매개 변수를 레지스터 내에 전달
    2. 매개변수는 메모리내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달
    3. 매개변수는 프로그램에 의해 <strong>스택</strong>에 넣어질 수 있고, OS에 의해 꺼내짐(블록이나 스택 방법을 선호 why? 전달되는 매개변수의 개수나 길이를 제한하지 않기 때문)

    <li><h4>2.4</h4></li>
    시스템 호출의 유형 : 프로세스제어, 파일조작, 장치조작, 정보유지보수, 통신, 보호
    프로그램 문제발생 -&gt; 오류트랩발생

    <li><h4>2.6 운영체제 설계 및 구현</h4></li>
    첫 번째 문제점 : 목적과 세부사항을 정의함에 따라 영향을 받음(시스템의 목표와 명세를 정의하는 일)

    설계요구조건
    -사용자목적 : 시스템이 사용하기 쉽고, 편리하며, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야 함
    -시스템목적 : OS는 설계, 구현, 유지 보수가 쉬워야 하며, 또한 적응성, 신뢰성, 무결성, 효율성을 가져야 함

    설계 시 중요한 원칙
    -메커니즘(Mechanism)으로부터 정책(Policy)을 분리하는 것
    메커니즘 : 어떤일을 어떻게(How)할 것인가를 결정하는 것 ex)CPU 보호 기법은 Timer로
    정책 : 무엇을(what)할 것인가를 결정하는 것 ex)Timer out 시간 결정
    -&gt 정책의 변경에 민감하지 않은 일반적인 메커니즘이 보다 바람직함 =&gt OS 디자인에는 정답이 없다.

    <li><h4>2.7 운영체제 구조</h4></li>
    <ol>
      <li>간단한 구조(Simple Structure)</li>
      범용 운영체제는 매우 큰 프로그램
      범용 운영체제의 구조는 다양한 방법
      간단한 구조 : MS-DOS
      좀 더 복잡한 : UNIX
      계층적 : 추상화 개념
      마이크로커널(Microkernel) : Mach

      *MS-DOS 구조
      H/W 한계 때문에 최소의 공간에서 최대의 기능을 제공하도록 작성
      모듈로 잘 분할되지 않았음(모놀리식 커널)
      커널의 구성요소들은 각 구소요소들간의 보호기능 없이 한곳에 위치, 악의적은 프로그램의 공격을 받기 쉬움

      <li>계층적 접근(Layered Approach)</li>
      주된 장점은 모듈화(Modularity) : 강력한 제어, 내부 시스템 변경의 자유로움, 특정 기능 집합의 구현 세부사항에 대한 은폐 방법
      OS는 다수의 층으로 분할되고, 각 층은 하위 층 위에서 구축됨(계층적 구성) : 최하위층(Layer 0)은 하드웨어, 최상위측(Layer N)은 사용자 인터페이스
      장점 : 시스템 검증과 디버킹 작업을 단순화
      단점 : 비효율적, 처리 시간 오버헤드(트랩(trap)의 연속)

      <li><strong>마이크로커널(Microkernel)</strong></li>
      <img src="../../images/OS/OS_mach.png" alt="" width="500" height="380">

      <strong>중요하지 않은 모든 구성 요소를 커널로부터 제거하고, 시스템 및 사용자 수준 프로그램으로 구현</strong>
      커널은 보안, IPC, H/W 상호 동작 등의 작은 수준만을 제공

      클라이언트 프로그램과 사용자 공간에서 수행되는 서비스간의 통신은 메시지 전달(Message Passing) 사용
      장점 : OS의 확장이 용이 - 커널 확장을 위해서 단지, 새로운 서버를 추가하면 됨
            모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널 변경을 필요로 하지 않음
            대부분의 서비스가 커널이 아니라 사용자 프로세스로 수행되기 때문에 또한 보다 높은 보안성과 신뢰성을 제공
      단점 : 성능 오버헤드 문제(사용자와 커널 프로세스간의 통신 오버헤드)

      대표적 OS <strong>Mach</strong>

      <li>모듈(Modules)</li>
      OS 설계하는데 이용되는 최근 기술 중 최선책은 아마도 <strong>적재가능 커널 모듈</strong>

      장점 : 핵심 서비스를 제공할 수 있게 할 뿐 아니라 특정 기능들을 동적으로 구현할 수 있게 해줌
      커널의 각 부분이 정의되고, 보호된 인터페이스를 가진다는 점에서 계층적 구조와 유사
      모듈이 임의의 다른 모듈을 호출할 수 있다는 점에서 계층적 구조보다 더 유연함
    </ol>

    <li><h4>2.8 운영체제 디버깅</h4></li>
    운영체제는 또한 프로세스가 사용하던 메모리를 캡쳐한 코어 덤프(core dump)를 취하고
    차후 분석을 위해 파일로 저장한다
    커널 장애는 충돌(crash)라고 불린다. 프로세스 장애와 마찬가지로 오류 정보가 로그 파일에
    저장되고 메모리의 상태가 충돌 덤프(crash dump)에 저장된다

    Dtrace : 실행 중인 시스템, 사용자 프로세스와 커널 모두에 동적으로 탐색점을 추가할 수 있는 설비

    <li><h4>2.9 운영체제 생성</h4></li>
    SYSGEN 프로그램 : H/W 시스템의 특정 구성에 대한 정보를 운영자에게 요구하거나, 주어진 파일로부터 읽어 들이거나,
    또는 어느 구성 요소가 있는지를 결정하기 위해 H/W를 직텁 테스트함

    <li><h4>2.10 시스템 부트</h4></li>
    부팅(Booting) : 커널을 적재하여 컴퓨터를 시동하는 절차
    부트스트랩 프로그램(Bootstrap Program) : ROM에 저장된 조그마한 코드로 커널을 찾아 그것을 메모리에 적재하고, 수행을 시작하도록 해줌
    ROM에 들어있거나 디스크 0번 세터에 있다.

    부트스트랩은 진단 절차를 수행하고 고정된 위치(예를 들면 블록 0)의 디스크 블록 하나를 읽어 메모리에 적재하고 그 위치로부터 실행시킬 수 있는 코드를 가진다.
    이 블록을 <strong>부트 블록</strong>이라고 한다. 부트 블록에 저장된 프로그램은 OS 전부를 메모리에 적재하고 실행을 시작할 수 있을 만큼 복잡할 수 있다.

    모든 부트 프로그램이 적재되면 파일 시스템을 탐색하여 OS 커널을 찾아내고 메모리로 적재한 후 실행을 시작한다. 시스템이 <strong>실행 중</strong>이라고 할 수 있는
    시점은 바로 이 시점이다.

</ul>
</pre>
