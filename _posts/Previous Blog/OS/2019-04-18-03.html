---
layout: post
title : "05 CPU 스케줄링 ~ 06 프로세스 동기화"
categories: [old]
tags: []
description: >
---
<h2>6단원</h2>
<pre>
  <ul>
    <h2><strong>프로세스 동기화</strong></h2>
    공유 데이터에 대한 동시 접근은 데이터의 비일관성을 낳을 수 있다.
    논리 주소 공간을 공유하는 협력적 프로세세의 질서 있는 실행을 보장하여,
    이를 통해 데이터의 일관성을 유지하는 다양한 메커니즘을 논의한다.

    <li><h4>6.1 배경 </h4></li>
    프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터 무결성에 어떤 문제를 일으키는지
    동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에
    의존하는 상황을 <strong>경쟁 상황(racd condition)</strong>이라고 한다.
    이러한 상황에서 데이터를 보호하기 위해 프로세스들이 동기화 되도록 해야함

    <li><h4>6.2 임계구역 문제(The Critical_Section Problem)</h4></li>
    각 프로세스는 임계구역을 가지고 있다. 한 프로세스가 자신의 임계구역에서 수행하는 동안에는
    다른 프로세스들은 그들의 임계구역에 들어갈 수 없다.
    임게구역 문제는 프로세들이 협력할 때 사용할 수 있는 프로토콜 설계이다.
    프로세스는 자신의 임계구역으로 진입하려면 진입허가를 요청해야한다. 이러한 요청을 구현하는
    코드 부분을 진입구역(entry section)이라고 하고 임계구역에 뒤에는 퇴출 구역(exit section)이 따라올 수 있다.
    코드의 나머지 부분은 나머지 구역(remainder section)이라 한다.

    임계구역 문제에 대한 해결안은 다음의 세가지 요구조건을 충족해야한다.
    <strong>
    1. 상호 배체(mutual exclusion)
    프로세스 Pi가 자기의 임계구역에서 실행된다면 다른 프로세스들은 그들 자신의 임계구역에서
    실행될 수 없다.

    2. 진행(proress)
    자기의 임계구역에서 실행되는 프로세스가 없고 그리고 그들 자신의 임계구역으로 진입하려고 하는
    프로세스들이 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 누가 그 임계구역으로
    진입할 수 있는 지를 결정하는데 참여할 수 있으며, 이 선택은 무한정 연기가 될 수없다.

    3. 한정된 대기(bounded waiting)
    프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이
    그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에
    한계가 있어야 한다.
    </strong>
    OS 내에서 임계구역을 다루기 위해 선점형 커널과 비선점형 커널의 두가지 일반적인 접근법이 사용된다
    선점형 커널 :
    프로세스가 커널모드에서 수행되는 동안 선점되는 것을 허용한다.
    비선점형 커널 :
    커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을
    빠져 나갈 때까지 또는 봉쇄될 때까지의 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행

    <li><h4>6.3 피터슨의 해결안</h4></li>
    Peterson's solution
    상호 배제, 진행, 한정된 대기의 요구조건을 모두 보장한다

    <li><h4>6.4 동기화 하드웨어</h4></li>
    피터슨해결안으로 두개가 넘는 프로세스에서는 해결이 불가함
    락킹에 대한 가정, 즉 임계구역을 보호하기 위해서 락을 사용하는 것에 기반을 둔다.

    임계구역 문제는 단일 처리기 환경에서는 공유 변수가 변경되는 동안 인터럽트 발생을 허용하지
    않음으로써 간단히 해결 할 수 있다. (비선점형 커널 방법)

    다중처리기 환경에서는 적용이 불가능함(인터럽트의 메시지 전달 시간이 너무큼)

    <strong>한 워드(word)의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적으로 교환 할 수 있는,
    즉 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령들을 사용하여 극복</strong>

    test_and_set() 과 compare_and_swap() 명령어가 있다.

    <pre class="highlight">
    Boolean test_and_set(boolean *target){
      boolean rv = *target;
      *target = true;
      return rv;
    }</pre>
    false로 초기화되는 lock이라는 Boolean변수를 선언하여 상호배제 구현
    <pre class="highlight">
    do{
      while (test_and_set(&lock))
        ; //do nothing
        // critical seciton

        lock = FALSE;

        // remainder section
    } while(true);</pre>

    실행 된 이후 FALSE로 값 초기화, 즉 다시 락을 해제
    compare_and_swap() 명령어 정의
    <pre class="highlight">
    int compare_and_swap(int *value, int expected, int new_value) {
    int temp = *value;
    if (*value == expected)
      *value = new_value;
      return temp;
    }</pre>
    위 두 알고리즘은 상호 배제 조건은 만족하지만 한정된 대기 조건은 만족시키지 못한다.

    한정된 대기 조건을 만족시키는 상호 배제 코드는 waiting[n] 과 lock을 사용한다

    <li><h4>6.5 Mutex Locks</h4></li>
    임계구역 문제를 해결하기 위한 소프트웨어 도구 중 하나가 <strong>mutex 락</strong>이다.
    mutual exclusion 의 약어로, 임계구역을 보호하고 경쟁조건을 방지하기 위해 mutex락을 사용한다.
    프로세스는 임계구역에 들어가기 전에 반드시 락을 획득해야 하고 임계구역을 빠져 나올 때 락을
    반환해야한다.
    acquire() 함수가 락을 획득하고, release() 함수가 락을 반환한다.
    mutex락은 available 이라는 불린 변수를 통해 락의 가용 여부 표시
    <pre class="highlight">
    acquire(){
      while(!available)
        ; /* busy wait */
        available = false;
    }
    ----------------------
    release(){
      available = true;
    }</pre>
    원자적으로 수행되어야 함
    이 방식의 단점은 바쁜 대기(busy waiting)을 해야 한다는 것이다.
    프로세스가 임계구역에 있는 동안 임계구역에 들어가기 원하는 다른 프로세스들은
    acquire()함수를 호출하는 반복문을 계속 실행해야 한다.
    프로세스가 계속 회전을 하고 있으므로 spinlock 이라고 부른다.

    <li><h4>6.6 세마포(Semaphores)</h4></li>
    mutex와 유사하게 동작하지만 프로세스들이 더 정교하게 동기화 할 수 있는 방법 - 세마포
    세마포 S는 정수 변수로서, 초기화를 제외하고는, 단지 두 개의 표준 원자적 연산 wait()와 signal()로만 접근 가능

    wait()와 signal()연산 시 세마포의 정수 값을 변경하는 연산은 반드시 분리되지 않고 수행되어야한다.
    즉 한 스레드가 세마포 값을 변경하면, 다른 어떤 스레드도 동시에 동일한 세마포 값을 변경할 수 없다.
    wait()을 P() signal을 V()라 부른다
    카운팅 세마포의 값은 제한 없는 영역을 갖는다.
    이진 세마포의 값은 0과 1사이의 값만 가능하다. 따라서 이진 세마포는 mutex 락과 유사하게 동작한다.
    세마포는 가용한 자원의 갯수로 초기화된다.
    세마포에 대해 두 프로세스가 동시에 wait()와 signal() 연산들을 실행할 수 없도록 반드시 보장해야한다.

    block()과 wakeup(p) , 대기큐를 활용하여 바쁜대기를 해결하려고 노력
    바쁜 대기를 완전하게 제거하지 못했다.
    임계구역은 거의 항상 비어 있으며, 바쁜 대기는 드물게 발생하며, 발생하더라도 그 시간이 아주 짧다.

    세마포를 잘못 사용하면 교착 상태와 기아(Deadlock and Starvation) 발생!!
    대기 큐를 가진 세마포의 구현은 두 개 이상의 프로세스들이 오로지 대기 중인 프로세들중 하나에 의해서만
    야기될 수 있는 사건을 무한정 기다리는 상황이 발생할 수 있다.
    이런 상태를 프로세스들을 교착 상태라고 한다.
    교착상태 - 대기중인프로세스들이 결코 다시는 그 상태를 변경시킬 수 없으면 이런 상황을 교착상태 라고한다.

    <li><h4>6.7 고전적인 동기화 문제들</h4></li>
    많은 클래스의 병행 제어 문제에 대한 예로서 중요한 여러 가지의 다른 동기화 문제들을 제시한다.

    1. 유한 버퍼 문제 - 생산자와 소비자가 한정된 공유 버퍼를 사용하는 문제, 동기화문제
    2. Readers-Writers 문제 - 공유 데이터에 대해 배타적 접근 권한을 가지게 할필요가있다. 동기화문제
    3. 식사하는 철학자들 문제 - 상호배제 문제, 데드락 발생, 기아 발생
    세마포사용하면 상호배제만 보장됨
    교착상태 해결법 : 4명만 테이블 앉거나, 비대칭 해결안 기타 등

    <li><h4>6.8 모니터</h4></li>
    세마포를 잘못 사용하면 생기는 문제
    signal(mutex) .... wait(mutex) - 다른 프로세스가 임계구역에 들어가게됨(상호배제 위반)
    wait(mutex) .... wait(mutex) - 세마포가 레디큐에 들어가버린다(교착 상태)

    이러한 오류들을 처리하기 위하여 고급 언어 구조물을 개발
    그 중에 하나가 모니터(monitors)

    사용법
    추상화 된 데이터 형은 데이터와 이 데이터를 조작하는 함수들의 집합을 하나의 단위로 묶어 보호한다.
    모니터 형은 모니터 내부에서 상호 배제가 보장되는 프로그래머가 정의한 일련의 연산자 집합을 포함하는 ADT이다

    모니터 구조물은 동기화 기법을 모델링하는데에는 충분한 능력이 없다. 그래서 condition 이라는 방법이 나옴

    condition()형 변수에 호출될 수 있는 연산은 오직 wait()과 signal()이다.

    식사하는철학자 - 모니터 : 데드락은 없지만 기아는 발생할 수있다.
    기아를 방지하려면 자신의 오른쪽만 pickup() 하면됨
    <li><h4>6.9 동기화 사례</h4></li>

    <li><h4>6.10 대체 방안들</h4></li>

    <li><h4>6.11 요약</h4></li>


</ul>
</pre>
